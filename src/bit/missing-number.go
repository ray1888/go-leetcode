package bit

/*

	原理解析：
	因为如果位置上是对应数字没有确实的话，
	XOR的运算时满足结合律的，因此可以把最终的结果全部和下标和数字本身进行异或
	由于异或运算（XOR）满足结合律，并且对一个数进行两次完全相同的异或运算会得到原来的数，因此我们可以通过异或运算找到缺失的数字。
	我们知道数组中有 nn 个数，并且缺失的数在 [0..n][0..n] 中。因此我们可以先得到 [0..n][0..n] 的异或值，再将结果对数组中的每一个数进行一次异或运算。未缺失的数在 [0..n][0..n] 和数组中各出现一次，因此异或后得到 0。而缺失的数字只在 [0..n][0..n] 中出现了一次，在数组中没有出现，因此最终的异或结果即为这个缺失的数字。

	在编写代码时，由于 [0..n][0..n] 恰好是这个数组的下标加上 nn，因此可以用一次循环完成所有的异或运算
	missing
​
	下标	0	1	2	3
	数字	0	1	3	4

	=4∧(0∧0)∧(1∧1)∧(2∧3)∧(3∧4)
	=(4∧4)∧(0∧0)∧(1∧1)∧(3∧3)∧2
	=0∧0∧0∧0∧2
	=2
​

*/

func missingNumber(nums []int) int {

	length := len(nums)
	result := length
	for i := 0; i < length; i++ {
		result = result ^ i ^ nums[i]
	}
	return result
}
